// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract TokenLockFactory is Ownable, ReentrancyGuard {
    uint256 public creationFee;
    address payable public feeRecipient;
    address[] public createdContracts;

    event TokenLockContractCreated(address indexed owner, address indexed tokenLockContract, uint256 creationFee);

    constructor(uint256 _creationFee, address payable _feeRecipient) {
        require(_feeRecipient != address(0), "INVALID_RECIPIENT");
        creationFee = _creationFee;
        feeRecipient = _feeRecipient;
    }

    function createTokenLockContract(address _token) public payable nonReentrant returns (address tokenLockContractAddress) {
        require(msg.value == creationFee, "INCORRECT_FEES");
        feeRecipient.transfer(msg.value);

        TokenLock newTokenLock = new TokenLock(_token, _msgSender());

        createdContracts.push(address(newTokenLock));

        emit TokenLockContractCreated(_msgSender(), address(newTokenLock), creationFee);
        return address(newTokenLock);
    }

    function updateCreationFee(uint256 _newFee) public onlyOwner {
        creationFee = _newFee;
    }

    function updateFeeRecipient(address payable _newRecipient) public onlyOwner {
        require(_newRecipient != address(0), "INVALID_RECIPIENT");
        feeRecipient = _newRecipient;
    }

    function getCreatedContracts() public view returns (address[] memory) {
        return createdContracts;
    }

}

contract TokenLock is Ownable, ReentrancyGuard {
    IERC20 public token;
    uint256 public totalLockedAmount;

    enum DurationType { Days, Months, Years }

    struct Lock {
        address owner;
        uint256 amount;
        uint256 lockEndTime;
        bool withdrawn;
    }

    Lock[] public locks;
    
    event Locked(address indexed owner, uint256 amount, uint256 lockEndTime);
    event Unlocked(address indexed owner, uint256 amount);

    constructor(address _token, address _owner) {
        token = IERC20(_token);
        transferOwnership(_owner);
    }

    function createLock(uint256 _amount, DurationType _durationType, uint256 _duration) public onlyOwner {
        require(_amount > 0, "Amount must be greater than 0");
        uint256 lockEndTime = calculateLockEndTime(_duration, _durationType);
        require(token.transferFrom(_msgSender(), address(this), _amount), "Transfer failed");

        locks.push(Lock({
            owner: _msgSender(),
            amount: _amount,
            lockEndTime: lockEndTime,
            withdrawn: false
        }));

        totalLockedAmount += _amount;

        emit Locked(_msgSender(), _amount, lockEndTime);
    }

    function unlockTokens(uint256 _lockId) public onlyOwner {
        require(_lockId < locks.length, "Invalid lock ID");
        Lock storage lock = locks[_lockId];
        require(lock.owner == _msgSender(), "Not the lock owner");
        require(!lock.withdrawn, "Already withdrawn");
        require(block.timestamp >= lock.lockEndTime, "Lock period not yet expired");

        lock.withdrawn = true;
        require(token.transfer(owner(), lock.amount), "Transfer failed");
        
        totalLockedAmount -= lock.amount;

        emit Unlocked(owner(), lock.amount);
    }

    function calculateLockEndTime(uint256 _duration, DurationType _durationType) private view returns (uint256) {
        if (_durationType == DurationType.Days) {
            return block.timestamp + _duration * 1 days;
        } else if (_durationType == DurationType.Months) {
            return block.timestamp + _duration * 30 days;
        } else if (_durationType == DurationType.Years) {
            return block.timestamp + _duration * 365 days;
        } else {
            revert("Invalid duration type");
        }
    }

    function TotalLocked() public view returns (uint256 totalLocked) {
        totalLocked = 0;
        for (uint256 i = 0; i < locks.length; i++) {
            if (!locks[i].withdrawn) {
                totalLocked += locks[i].amount;
            }
        }
    }

    function getStakingTokenDecimals() public view returns (uint8) {
        return IERC20Metadata(address(token)).decimals();
    }

    function getLockPeriod() public view returns (uint256[] memory amounts, uint256[] memory unlockTimes, uint256 totalLocked) {
        uint256 lockCount = 0;
        totalLocked = 0;

        // Count the number of active locks for the owner and calculate total locked tokens
        for (uint256 i = 0; i < locks.length; i++) {
            if (locks[i].owner == owner() && !locks[i].withdrawn) {
                lockCount++;
                totalLocked += locks[i].amount;
            }
        }

        // Initialize the arrays for individual lock details
        amounts = new uint256[](lockCount);
        unlockTimes = new uint256[](lockCount);

        // Populate the arrays with individual lock details
        uint256 currentIndex = 0;
        for (uint256 i = 0; i < locks.length; i++) {
            if (locks[i].owner == owner() && !locks[i].withdrawn) {
                amounts[currentIndex] = locks[i].amount;
                unlockTimes[currentIndex] = locks[i].lockEndTime;
                currentIndex++;
            }
        }
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ITokenFactory {
    function updateCreationFee(uint256 _newFee) external;
    function updateFeeRecipient(address payable _newRecipient) external;
    function updateGovContract(address _newContract) external;
}

interface INewToken {
    function removeLockedTokenContract(address _address) external;
    function removeVestedTokenContract(address _address) external;
    function removeStakingTokenContract(address _address) external;
    function removeLiquidityPool(address _pool) external;
    function modifyBuyTax(uint256 _newTaxPercent) external;
    function modifySellTax(uint256 _newTaxPercent) external;
    function modifyBurnTax(uint256 _newTaxPercent) external;
    function mint(address _to, uint256 _amount) external;
    function updateTreasury(address _treasury) external;
    function disableMinting() external;
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

contract Governance {
    address public tokenFactoryAddress;
    address public owner;
    IERC20 public votingToken;
    bool private votingTokenSet;
    uint256 public minimumQuorum;
    uint256 public debatingPeriodDuration;
    
    enum ProposalType { UpdateCreationFee, UpdateFeeRecipient, UpdateGovernanceContract, UpdateTokenFactoryAddress }
    enum ProposalType2 { RemoveLockedTokenContract, RemoveVestedTokenContract, RemoveStakingTokenContract, RemoveLiquidityPool }
    enum TaxProposalType { UpdateBuyTax, UpdateSellTax, UpdateBurnTax }
    enum ManageProposalType { MintTokens, UpdateTreasury, DisableMint }

    struct Proposal {
        uint256 id;
        ProposalType proposalType;
        uint256 newFee;
        address newFeeRecipient;
        address newTokenFactoryAddress;
        address newGovernanceContractAddress;
        uint256 voteCountYes;
        uint256 voteCountNo;
        bool executed;
        mapping(address => bool) voted;
    }

    struct Proposal2 {
        uint256 id;
        ProposalType2 proposalType;
        address removeLockedContract;
        address removeVestedContract;
        address removeStakedContract;
        address removeLP;
        uint256 voteCountYes;
        uint256 voteCountNo;
        bool executed;
        mapping(address => bool) voted;
    }

    struct ModifyTax {
        uint256 id;
        TaxProposalType proposalType;
        uint256 newBuyTax;
        uint256 newSellTax;
        uint256 newBurnTax;
        uint256 voteCountYes;
        uint256 voteCountNo;
        bool executed;
        mapping(address => bool) voted;
    }

    struct ManageTokens {
        uint256 id;
        ManageProposalType proposalType;
        address to;
        uint256 amount;
        address treasuryAddress;
        uint256 voteCountYes;
        uint256 voteCountNo;
        bool executed;
        mapping(address => bool) voted;
    }
    

    uint256 public nextProposalId;
    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => Proposal2) public proposal2s;
    mapping(uint256 => ModifyTax) public modifyTax;
    mapping(uint256 => ManageTokens) public manageTokensProposals;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _; 
    }

    constructor(address _tokenFactoryAddress, uint256 _minimumQuorum, uint256 _debatingPeriodDuration) {
        tokenFactoryAddress = _tokenFactoryAddress;
        owner = msg.sender;
        minimumQuorum = _minimumQuorum;
        debatingPeriodDuration = _debatingPeriodDuration;
    }

    function setVotingToken(address _votingToken) public onlyOwner {
        require(!votingTokenSet, "Voting token already set");
        votingToken = IERC20(_votingToken);
        votingTokenSet = true;
    }

    function createFactoryProposal(ProposalType _type, uint256 _newFee, address _newAddress) public onlyOwner {
        Proposal storage p = proposals[nextProposalId];
        p.id = nextProposalId;
        p.proposalType = _type;

    if (_type == ProposalType.UpdateCreationFee) {
        p.newFee = _newFee;
    } else if (_type == ProposalType.UpdateFeeRecipient) {
        p.newFeeRecipient = _newAddress;
    } else if (_type == ProposalType.UpdateGovernanceContract) {
        p.newGovernanceContractAddress = _newAddress;
    } else if (_type == ProposalType.UpdateTokenFactoryAddress) {
        p.newTokenFactoryAddress = _newAddress;
    }

        p.executed = false;
        nextProposalId++;
    }
    
    function removeContractProposal(ProposalType2 _type, address _contractAddress) public onlyOwner {
        Proposal2 storage p2 = proposal2s[nextProposalId];
        p2.id = nextProposalId;
        p2.proposalType = _type;

    if (_type == ProposalType2.RemoveLockedTokenContract) {
        p2.removeLockedContract = _contractAddress;
    } else if (_type == ProposalType2.RemoveVestedTokenContract) {
        p2.removeVestedContract = _contractAddress;
    } else if (_type == ProposalType2.RemoveStakingTokenContract) {
        p2.removeStakedContract = _contractAddress;
    } else if (_type == ProposalType2.RemoveLiquidityPool) {
        p2.removeLP = _contractAddress;
    }
    
        p2.executed = false;
        nextProposalId++;
    }

    function modifyTaxProposal(TaxProposalType _type, uint256 _newTax) public {
        ModifyTax storage t = modifyTax[nextProposalId];
        t.id = nextProposalId;
        t.proposalType = _type;

    if (_type == TaxProposalType.UpdateBuyTax) {
        t.newBuyTax = _newTax;
    } else if (_type == TaxProposalType.UpdateSellTax) {
        t.newSellTax = _newTax;
    } else if (_type == TaxProposalType.UpdateBurnTax) {
        t.newBurnTax = _newTax;
    }
    
        t.executed = false;
        nextProposalId++;
    }

    function createManageTokensProposal(ManageProposalType _type, address _to, uint256 _amount, address _treasuryAddress) public onlyOwner {
        ManageTokens storage m = manageTokensProposals[nextProposalId];
        m.id = nextProposalId;
        m.proposalType = _type;
    
        if (_type == ManageProposalType.MintTokens) {
            m.to = _to;
            m.amount = _amount;
        } else if (_type == ManageProposalType.UpdateTreasury) {
            m.treasuryAddress = _treasuryAddress;
        } // No need for an else branch for DisableMint as it requires no parameters
        
        m.executed = false;
        nextProposalId++;
    }

    function vote(uint256 _proposalId, bool _voteYes) public {
        require(votingTokenSet, "Voting token not set");
        require(votingToken.balanceOf(msg.sender) > 0, "Not a token holder");

        Proposal storage p = proposals[_proposalId];
        require(!p.executed, "Proposal already executed");
        require(!p.voted[msg.sender], "Already voted");

        p.voted[msg.sender] = true;
        if (_voteYes) {
            p.voteCountYes++;
        } else {
            p.voteCountNo++;
        }
    }
    
    function executeFactoryProposal(uint256 _proposalId) public {
        Proposal storage p = proposals[_proposalId];
        require(!p.executed, "Proposal already executed");
        require(p.voteCountYes > p.voteCountNo, "Proposal did not pass");
        require(p.voteCountYes >= minimumQuorum, "Not enough votes");

        if (p.proposalType == ProposalType.UpdateCreationFee) {
            ITokenFactory(tokenFactoryAddress).updateCreationFee(p.newFee);
            } else if (p.proposalType == ProposalType.UpdateFeeRecipient) {
                ITokenFactory(tokenFactoryAddress).updateFeeRecipient(payable(p.newFeeRecipient));
            } else if (p.proposalType == ProposalType.UpdateGovernanceContract) {
                require(p.newGovernanceContractAddress != address(0), "Invalid address");    
                ITokenFactory(tokenFactoryAddress).updateGovContract(p.newGovernanceContractAddress);
            } else if (p.proposalType == ProposalType.UpdateTokenFactoryAddress) {
                require(p.newTokenFactoryAddress != address(0), "Invalid address");
                tokenFactoryAddress = p.newTokenFactoryAddress;
            } 
            p.executed = true;
        }
        
        function executeRemoveContract (uint256 _proposalId, address _contractAddress) public {
            Proposal2 storage p2 = proposal2s[_proposalId];
            require(!p2.executed, "Proposal already executed");
            require(p2.voteCountYes > p2.voteCountNo, "Proposal did not pass");
            require(p2.voteCountYes >= minimumQuorum, "Not enough votes");
    
        if (p2.proposalType == ProposalType2.RemoveLockedTokenContract) {
            INewToken(_contractAddress).removeLockedTokenContract(p2.removeLockedContract);
            } else if (p2.proposalType == ProposalType2.RemoveVestedTokenContract) {
                //require(p.newGovernanceContractAddress != address(0), "Invalid address");    
                INewToken(_contractAddress).removeVestedTokenContract(p2.removeVestedContract);
            } else if (p2.proposalType == ProposalType2.RemoveStakingTokenContract) {
                INewToken(_contractAddress).removeStakingTokenContract(p2.removeStakedContract);
            } else if (p2.proposalType == ProposalType2.RemoveLiquidityPool) {
                //require(p.newGovernanceContractAddress != address(0), "Invalid address");    
                INewToken(_contractAddress).removeLiquidityPool(p2.removeLP);
            }
        p2.executed = true;
    }

    function executeTaxChange (uint256 _proposalId, address _contractAddress) public {
            ModifyTax storage t = modifyTax[_proposalId];
            require(!t.executed, "Proposal already executed");
            require(t.voteCountYes > t.voteCountNo, "Proposal did not pass");
            require(t.voteCountYes >= minimumQuorum, "Not enough votes");
    
        if (t.proposalType == TaxProposalType.UpdateBuyTax) {
            INewToken(_contractAddress).modifyBuyTax(t.newBuyTax);
            } else if (t.proposalType == TaxProposalType.UpdateSellTax) {
                INewToken(_contractAddress).modifyBuyTax(t.newSellTax);
            } else if (t.proposalType == TaxProposalType.UpdateBurnTax) {
                INewToken(_contractAddress).modifyBuyTax(t.newBurnTax);
            }
        t.executed = true;
    }

    function executeManageTokensProposal(uint256 _proposalId, address _contractAddress) public {
        ManageTokens storage m = manageTokensProposals[_proposalId];
        require(!m.executed, "Proposal already executed");
        require(m.voteCountYes > m.voteCountNo, "Proposal did not pass");
        require(m.voteCountYes >= minimumQuorum, "Not enough votes");
    
        if (m.proposalType == ManageProposalType.MintTokens) {
            require(m.amount > 0, "Invalid mint amount");
            INewToken(_contractAddress).mint(m.to, m.amount);
        } else if (m.proposalType == ManageProposalType.UpdateTreasury) {
            require(m.treasuryAddress != address(0), "Invalid treasury address");
            INewToken(_contractAddress).updateTreasury(m.treasuryAddress);
        } else if (m.proposalType == ManageProposalType.DisableMint) {
            INewToken(_contractAddress).disableMinting();
        }
        m.executed = true;
    }

}

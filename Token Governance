// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IStakingContract {
    function balanceOf(address account) external view returns (uint256);
    function totalStaked() external view returns (uint256);
}

interface ITokenFactory {
    function updateCreationFee(uint256 _newFee) external;
    function updateFeeRecipient(address payable _newRecipient) external;
    function updateGovContract(address _newContract) external;
}

interface INewToken {
    function removeLockedTokenContract(address _address) external;
    function removeVestedTokenContract(address _address) external;
    function removeStakingTokenContract(address _address) external;
    function removeLiquidityPool(address _pool) external;
    function isLockedTokenContract(address _address) external view returns (bool);
    function isVestedTokenContract(address _address) external view returns (bool);
    function isStakingTokenContract(address _address) external view returns (bool);
    function isLiquidityPoolAddress(address _pool) external view returns (bool);
    function modifyBuyTax(uint256 _newTaxPercent) external;
    function modifySellTax(uint256 _newTaxPercent) external;
    function modifyBurnTax(uint256 _newTaxPercent) external;
    function mint(address _to, uint256 _amount) external;
    function updateTreasury(address _treasury) external;
    function disableMinting() external;
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IBurnableToken is IERC20 {
    function burn(uint256 amount) external;
}

contract Governance {
    address public stakingContractAddress;
    address public tokenFactoryAddress;
    address public owner;
    IBurnableToken public votingToken;
    bool private votingTokenSet;
    uint256 public minimumQuorum;
    uint256 public votingPeriod;
    uint256 public maxVotingPowerPercentage;
    uint256 public proposalCreationThreshold;
    uint256 public nextProposalId;

    enum ProposalType { 
        UpdateCreationFee, UpdateFeeRecipient, UpdateGovernanceContract, UpdateTokenFactoryAddress,
        RemoveLockedTokenContract, RemoveVestedTokenContract, RemoveStakingTokenContract, RemoveLiquidityPool,
        UpdateBuyTax, UpdateSellTax, UpdateBurnTax, MintTokens, UpdateTreasury, DisableMint
    }

    struct VotingState {
        uint256 voteCountYes;
        uint256 voteCountNo;
        mapping(address => bool) voted;
    }

    struct Proposal {
        uint256 id;
        ProposalType proposalType;
        address targetContract;
        uint256 numericValue;
        address addrValue;
        bool executed;
        uint256 startTime;
        uint256 endTime;
        VotingState votingState;
    }

    mapping(uint256 => Proposal) private proposals;
    
    event VotingTokenUpdated(address indexed newVotingToken);
    event ProposalCreated(uint256 indexed proposalId, ProposalType proposalType, address indexed createdBy);
    event VoteCast(address indexed voter, uint256 indexed proposalId, bool voteYes, uint256 votingPower, uint256 voteCountYes, uint256 voteCountNo);
    event ProposalExecuted(uint256 indexed proposalId, ProposalType proposalType, address indexed executedBy);
    event MaxVotingPowerPercentageUpdated(uint256 newMaxVotingPowerPercentage);
    event StakingContractUpdated(address indexed newStakingContract);
    event ProposalCreationThresholdUpdated(uint256 newThreshold);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(
        address _tokenFactoryAddress, 
        uint256 _minimumQuorum, 
        uint256 _votingPeriod, 
        uint256 _maxVotingPowerPercentage, 
        uint256 _proposalCreationThreshold
        ) {
        owner = msg.sender;
        tokenFactoryAddress = _tokenFactoryAddress;
        minimumQuorum = _minimumQuorum;
        votingPeriod = _votingPeriod;
        maxVotingPowerPercentage = _maxVotingPowerPercentage;
        proposalCreationThreshold = _proposalCreationThreshold;
    }

    function setVotingToken(address _votingToken) public onlyOwner {
        require(!votingTokenSet, "Voting token already set");
        votingToken = IBurnableToken(_votingToken);
        votingTokenSet = true;
        emit VotingTokenUpdated(_votingToken);
    }

    function setStakingContract(address _stakingContract) public onlyOwner {
        stakingContractAddress = _stakingContract;
        emit StakingContractUpdated(_stakingContract);
    }

    function updateMaxVotingPowerPercentage(uint256 _newMaxVotingPowerPercentage) public onlyOwner {
        require(_newMaxVotingPowerPercentage >= 3 && _newMaxVotingPowerPercentage <= 8, "Invalid max voting power percentage");
        maxVotingPowerPercentage = _newMaxVotingPowerPercentage;
        emit MaxVotingPowerPercentageUpdated(_newMaxVotingPowerPercentage);
    }

    function updateProposalCreationThreshold(uint256 _newThreshold) public onlyOwner {
        require(_newThreshold >= 10 && _newThreshold <= 100, "NOT_IN_RANGE");
        proposalCreationThreshold = _newThreshold;
        emit ProposalCreationThresholdUpdated(_newThreshold);
    }

    function createProposal(
        ProposalType _type, 
        address _targetContract, 
        uint256 _numericValue, 
        address _addrValue
    ) public {
        require(votingToken.balanceOf(msg.sender) >= proposalCreationThreshold, "Insufficient balance to create proposal");
        votingToken.transferFrom(msg.sender, address(this), proposalCreationThreshold);
        burnTokens(proposalCreationThreshold);

        uint256 newProposalId = nextProposalId++;
        Proposal storage p = proposals[newProposalId];
        p.id = newProposalId;
        p.proposalType = _type;
        p.targetContract = _targetContract;
        p.numericValue = _numericValue;
        p.addrValue = _addrValue;
        p.startTime = block.timestamp;
        p.endTime = p.startTime + votingPeriod;
        p.executed = false;

        emit ProposalCreated(newProposalId, _type, msg.sender);
    }

    function burnTokens(uint256 _amount) private {
        IBurnableToken(address(votingToken)).burn(_amount);
    }

    function vote(uint256 _proposalId, bool _voteYes) public {
        _castVote(_proposalId, _voteYes);
    }

    function _castVote(uint256 _proposalId, bool _voteYes) private {
        require(votingTokenSet, "Voting token not set");
        IStakingContract stakingContract = IStakingContract(stakingContractAddress);
        uint256 voterStake = stakingContract.balanceOf(msg.sender);
        require(voterStake > 0, "Not a staked token holder");
        Proposal storage p = proposals[_proposalId];
        require(!p.votingState.voted[msg.sender], "Already voted");
        require(!p.executed, "Proposal already executed");
        require(block.timestamp >= p.startTime && block.timestamp <= p.endTime, "Voting period is over");

        uint256 totalStaked = stakingContract.totalStaked();
        uint256 votingPower = (voterStake * 100) / totalStaked;
        uint256 maxVotingPower = (totalStaked * maxVotingPowerPercentage) / 100;
        if (voterStake > maxVotingPower) {
            votingPower = (maxVotingPower * 100) / totalStaked;
        }
        p.votingState.voted[msg.sender] = true;
        if (_voteYes) {
            p.votingState.voteCountYes += votingPower;
        } else {
            p.votingState.voteCountNo += votingPower;
        }
        
        emit VoteCast(msg.sender, _proposalId, _voteYes, votingPower, p.votingState.voteCountYes, p.votingState.voteCountNo);
    }

    function executeProposal(uint256 _proposalId) public {
        Proposal storage p = proposals[_proposalId];
        require(!p.executed, "Proposal already executed");
        require(block.timestamp > p.endTime, "Voting period not over yet");
        require(p.votingState.voteCountYes > p.votingState.voteCountNo, "Proposal did not pass");
        require(p.votingState.voteCountYes >= minimumQuorum, "Not enough votes");

        // Execute proposal based on type
        if (p.proposalType == ProposalType.UpdateCreationFee) {
            ITokenFactory(tokenFactoryAddress).updateCreationFee(p.numericValue);
        } else if (p.proposalType == ProposalType.UpdateFeeRecipient) {
            ITokenFactory(tokenFactoryAddress).updateFeeRecipient(payable(p.addrValue));
        } else if (p.proposalType == ProposalType.UpdateGovernanceContract) {
            require(p.addrValue != address(0), "Invalid address");
            ITokenFactory(tokenFactoryAddress).updateGovContract(p.addrValue);
        } else if (p.proposalType == ProposalType.UpdateTokenFactoryAddress) {
            require(p.addrValue != address(0), "Invalid address");
            tokenFactoryAddress = p.addrValue;
        } else {
            INewToken targetContract = INewToken(p.targetContract);
            executeTokenRelatedProposal(p, targetContract);
        }

        p.executed = true;
        emit ProposalExecuted(_proposalId, p.proposalType, msg.sender);
    }

    function executeTokenRelatedProposal(Proposal storage p, INewToken targetContract) internal {
        
        if (p.proposalType == ProposalType.RemoveLockedTokenContract) {
            require(targetContract.isLockedTokenContract(p.addrValue), "Address not found in locked contracts");
            targetContract.removeLockedTokenContract(p.addrValue);
        } else if (p.proposalType == ProposalType.RemoveVestedTokenContract) {
            require(targetContract.isVestedTokenContract(p.addrValue), "Address not found in vested contracts");
            targetContract.removeVestedTokenContract(p.addrValue);
        } else if (p.proposalType == ProposalType.RemoveStakingTokenContract) {
            require(targetContract.isStakingTokenContract(p.addrValue), "Address not found in staking contracts");
            targetContract.removeStakingTokenContract(p.addrValue);
        } else if (p.proposalType == ProposalType.RemoveLiquidityPool) {
            require(targetContract.isLiquidityPoolAddress(p.addrValue), "Address not found in liquidity pools");
            targetContract.removeLiquidityPool(p.addrValue);
        } else if (p.proposalType == ProposalType.UpdateBuyTax) {
            targetContract.modifyBuyTax(p.numericValue);
        } else if (p.proposalType == ProposalType.UpdateSellTax) {
            targetContract.modifySellTax(p.numericValue);
        } else if (p.proposalType == ProposalType.UpdateBurnTax) {
            targetContract.modifyBurnTax(p.numericValue);
        } else if (p.proposalType == ProposalType.MintTokens) {
            require(p.numericValue > 0, "Invalid mint amount");
            targetContract.mint(p.addrValue, p.numericValue);
        } else if (p.proposalType == ProposalType.UpdateTreasury) {
            require(p.addrValue != address(0), "Invalid treasury address");
            targetContract.updateTreasury(p.addrValue);
        } else if (p.proposalType == ProposalType.DisableMint) {
            targetContract.disableMinting();
        }
    }

    function getProposal(uint256 _proposalId) public view returns (ProposalType, address, uint256, address, bool, uint256, uint256) {
        Proposal storage p = proposals[_proposalId];
        return (p.proposalType, p.targetContract, p.numericValue, p.addrValue, p.executed, p.startTime, p.endTime);
    }

}

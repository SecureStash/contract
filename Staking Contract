// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract StakingContractFactory is Ownable, ReentrancyGuard {
    uint256 public creationFee;
    address payable public feeRecipient;
    address[] public createdContracts;

    event StakingContractCreated(address indexed owner, address indexed stakingContract, uint256 creationFee);

    constructor(uint256 _creationFee, address payable _feeRecipient) {
        require(_feeRecipient != address(0), "INVALID_RECIPIENT");
        creationFee = _creationFee;
        feeRecipient = _feeRecipient;
    }

    function createStakingContract(
        address _stakingToken,
        address _rewardToken,
        uint256 _rewardRate,
        uint256 _unstakeDurationDays,
        bool _rewardsEnabled
    ) public payable nonReentrant returns (address) {
        require(msg.value == creationFee, "INCORRECT_FEES");
        feeRecipient.transfer(msg.value);

        StakingContract newStakingContract = new StakingContract(
            _stakingToken,
            _rewardToken,
            _rewardRate,
            _unstakeDurationDays,
            _rewardsEnabled,
            _msgSender()
        );

        createdContracts.push(address(newStakingContract));

        emit StakingContractCreated(_msgSender(), address(newStakingContract), creationFee);

        return address(newStakingContract);
    }

    function updateCreationFee(uint256 _newFee) public onlyOwner {
        creationFee = _newFee;
    }

    function updateFeeRecipient(address payable _newRecipient) public onlyOwner {
        require(_newRecipient != address(0), "INVALID_RECIPIENT");
        feeRecipient = _newRecipient;
    }

    function getCreatedContracts() public view returns (address[] memory) {
        return createdContracts;
    }
}

contract StakingContract is ReentrancyGuard, Ownable {
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    uint256 public rewardRate;
    uint256 public unstakeDuration;
    bool public rewardsEnabled;

    struct UnstakeRequest {
        uint256 amount;
        uint256 unstakeTime;
    }

    struct StakingInfo {
        uint256 amountStaked;
        uint256 rewardDebt;
        UnstakeRequest[] unstakeRequests;
    }

    mapping(address => StakingInfo) public stakers;

    uint256 private totalStaked;
    uint256 private totalPendingUnstake;

    event Staked(address indexed staker, uint256 amount);
    event UnstakeRequested(address indexed staker, uint256 amount);
    event Unstaked(address indexed staker, uint256 amount);
    event RewardClaimed(address indexed staker, uint256 reward);
    event RewardsToggled(bool enabled);

    constructor(
        address _stakingToken,
        address _rewardToken,
        uint256 _rewardRate,
        uint256 _unstakeDurationDays,
        bool _rewardsEnabled,
        address _owner
    ) Ownable() {
        stakingToken = IERC20(_stakingToken);
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
        unstakeDuration = _unstakeDurationDays * 1 days;
        rewardsEnabled = _rewardsEnabled;
        transferOwnership(_owner);
    }

    function stake(uint256 _amount) public nonReentrant {
        require(_amount > 0, "Cannot stake 0");

        StakingInfo storage staker = stakers[_msgSender()];
        require(stakingToken.transferFrom(_msgSender(), address(this), _amount), "Transfer failed");
        staker.amountStaked += _amount;
        totalStaked += _amount;

        emit Staked(_msgSender(), _amount);
    }

    function requestUnstake(uint256 _amount) public nonReentrant {
        StakingInfo storage staker = stakers[_msgSender()];
        require(_amount > 0 && _amount <= staker.amountStaked, "Invalid unstake amount");

        staker.amountStaked -= _amount;
        staker.unstakeRequests.push(UnstakeRequest({
            amount: _amount,
            unstakeTime: block.timestamp + unstakeDuration
        }));
        totalStaked -= _amount;
        totalPendingUnstake += _amount;

        emit UnstakeRequested(_msgSender(), _amount);
    }

    function unstake() public nonReentrant {
        StakingInfo storage staker = stakers[_msgSender()];
        uint256 totalUnstakedAmount = 0;

        for (uint256 i = 0; i < staker.unstakeRequests.length; ) {
            if (block.timestamp >= staker.unstakeRequests[i].unstakeTime) {
                uint256 amountToUnstake = staker.unstakeRequests[i].amount;
                require(stakingToken.transfer(_msgSender(), amountToUnstake), "Transfer failed");

                totalUnstakedAmount += amountToUnstake;
                totalPendingUnstake -= amountToUnstake;
                removeUnstakeRequest(staker.unstakeRequests, i);
            // No need to increment i, as the next item has shifted to current position
            } else {
                i++;    // Only increment if we didn't remove an item, to avoid skipping

            }
        }

        require(totalUnstakedAmount > 0, "No pending unstake available or unstake period not reached");
        emit Unstaked(_msgSender(), totalUnstakedAmount);
    }

    function removeUnstakeRequest(UnstakeRequest[] storage requests, uint index) internal {
        require(index < requests.length, "Index out of bounds");

        for (uint256 i = index; i < requests.length - 1; i++) {
            requests[i] = requests[i + 1];
        }
        requests.pop();
    }

    function claimReward() public nonReentrant {
        require(rewardsEnabled, "Rewards are disabled");

        StakingInfo storage staker = stakers[_msgSender()];
        uint256 reward = calculateReward(_msgSender());

        require(reward > 0, "No rewards available");
        require(rewardToken.transfer(_msgSender(), reward), "Transfer failed");

        staker.rewardDebt += reward;

        emit RewardClaimed(_msgSender(), reward);
    }

    function calculateReward(address _staker) public view returns (uint256) {
        if (!rewardsEnabled) return 0;

        StakingInfo storage staker = stakers[_staker];
        // Implement updated reward calculation logic based on your requirements
        uint256 reward = (staker.amountStaked * rewardRate) / 1e18; // Example
        return reward - staker.rewardDebt;
    }

    function toggleRewards() public onlyOwner {
        rewardsEnabled = !rewardsEnabled;
        emit RewardsToggled(rewardsEnabled);
    }

    function updateUnstakeDuration(uint256 _days) public onlyOwner {
        unstakeDuration = _days * 1 days;
    }

    function updateRewardRate(uint256 _newRate) public onlyOwner {
        rewardRate = _newRate;
    }

    function getStakerTokenBalance(address _staker) public view returns (uint256) {
        return stakingToken.balanceOf(_staker);
    }

    function getStakerAmountStaked(address _staker) public view returns (uint256) {
        return stakers[_staker].amountStaked;
    }

    function getStakerPendingUnstake(address _staker) public view returns (uint256) {
        StakingInfo storage staker = stakers[_staker];
        uint256 totalPending = 0;
        for (uint256 i = 0; i < staker.unstakeRequests.length; i++) {
            totalPending += staker.unstakeRequests[i].amount;
        }
        return totalPending;
    }

    function getStakingTokenDecimals() public view returns (uint8) {
        return IERC20Metadata(address(stakingToken)).decimals();
    }

    function TotalStaked() public view returns (uint256) {
        return totalStaked;
    }

    function TotalPendingUnstake() public view returns (uint256) {
        return totalPendingUnstake;
    }

}
